"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[8349],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>f});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=n.createContext({}),c=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(r),f=a,h=p["".concat(i,".").concat(f)]||p[f]||u[f]||o;return r?n.createElement(h,l(l({ref:t},d),{},{components:r})):n.createElement(h,l({ref:t},d))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=p;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var c=2;c<o;c++)l[c]=r[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},22541:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const o={title:"Helper Functions",sidebar_position:3},l=void 0,s={unversionedId:"crosstalkutils-library/helper-functions",id:"crosstalkutils-library/helper-functions",title:"Helper Functions",description:"toBytes",source:"@site/docs/crosstalk/crosstalkutils-library/helper-functions.md",sourceDirName:"crosstalkutils-library",slug:"/crosstalkutils-library/helper-functions",permalink:"/crosstalk/crosstalkutils-library/helper-functions",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/crosstalk/crosstalkutils-library/helper-functions.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Helper Functions",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"How to Use the CrossTalkUtils Library",permalink:"/crosstalk/crosstalkutils-library/how-to-use-the-crosstalkutils-library"},next:{title:"Guides",permalink:"/crosstalk/category/guides"}},i={},c=[{value:"<code>toBytes</code>",id:"tobytes",level:3},{value:"<code>toAddress</code>",id:"toaddress",level:3},{value:"<code>getTxStatusForAtomicCall</code>",id:"gettxstatusforatomiccall",level:3},{value:"<code>getTheIndexOfCallFailure</code>",id:"gettheindexofcallfailure",level:3}],d={toc:c};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"tobytes"},(0,a.kt)("inlineCode",{parentName:"h3"},"toBytes")),(0,a.kt)("p",null,"A function to convert type address to type bytes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function toBytes(address addr) internal pure returns (bytes memory b){\n  assembly {\n      let m := mload(0x40)\n      addr := and(addr, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, addr))\n      mstore(0x40, add(m, 52))\n      b := m\n  }\n}\n")),(0,a.kt)("h3",{id:"toaddress"},(0,a.kt)("inlineCode",{parentName:"h3"},"toAddress")),(0,a.kt)("p",null,"A function to convert type bytes to type address:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n    bytes20 srcTokenAddress;\n    assembly {\n        srcTokenAddress := mload(add(_bytes, 0x20))\n    }\n    addr = address(srcTokenAddress);\n}\n")),(0,a.kt)("h3",{id:"gettxstatusforatomiccall"},(0,a.kt)("inlineCode",{parentName:"h3"},"getTxStatusForAtomicCall")),(0,a.kt)("p",null,"When you send multiple contract calls to the destination chain with the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"isAtomicCalls"))," flag set as true, either all the calls will be executed or none of the calls will be executed. When the acknowledgement comes back on the source chain, a parameter called ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"execFlags")),", an array of booleans, denotes which calls were executed and which failed."),(0,a.kt)("p",null,"Since this is the case of atomic calls, we are sure that either all the call were executed or none of the calls were executed. But for the purposes of debugging, we provide ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"true"))," in the array till the point of failure so that the developer knows exactly which call failed."),(0,a.kt)("p",null,"Besides the acknowledgment, developers can use the function ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"getTxStatusForAtomicCall"))," to fetch whether the calls were successfully executed on the destination chain."),(0,a.kt)("h3",{id:"gettheindexofcallfailure"},(0,a.kt)("inlineCode",{parentName:"h3"},"getTheIndexOfCallFailure")),(0,a.kt)("p",null,"In case of atomic calls, the function ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"getTheIndexOfCallFailure"))," can be used to get the index of the call that failed on the destination chain. Note that this function will throw an error if all the calls were successfully executed. Therefore, it is advised that you check whether or not ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"getTxStatusForAtomicCall"))," returns false before calling this function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function getTheIndexOfCallFailure(\n    bool[] calldata execFlags\n) internal pure returns (uint8);\n")))}u.isMDXComponent=!0}}]);