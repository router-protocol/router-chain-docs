"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[954],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,f=p["".concat(l,".").concat(u)]||p[u]||h[u]||o;return n?r.createElement(f,s(s({ref:t},c),{},{components:n})):r.createElement(f,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var d=2;d<o;d++)s[d]=n[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},97365:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const o={title:"Transfer of Reserve Tokens",sidebar_position:2},s=void 0,i={unversionedId:"understanding-voyager/transfer-reserve-token",id:"understanding-voyager/transfer-reserve-token",title:"Transfer of Reserve Tokens",description:"Reserve tokens are the tokens that have been kept in reserve by the Voyager protocol. The Voyager keeps reserves of some selected tokens on each chain so that it is able to provide fund transfers by locking funds on source chain and unlocking the funds on the destination chain. These include some stable tokens, wrapped native tokens for that chain as well as other tokens according to the needs as well as partnerships of projects with the Voyager .",source:"@site/docs/voyager/understanding-voyager/transfer-reserve-token.md",sourceDirName:"understanding-voyager",slug:"/understanding-voyager/transfer-reserve-token",permalink:"/voyager/understanding-voyager/transfer-reserve-token",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/voyager/understanding-voyager/transfer-reserve-token.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Transfer of Reserve Tokens",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Understanding different functions of Voyager",permalink:"/voyager/understanding-voyager/understanding-different-functions"},next:{title:"Transfer of Reserve Tokens with Arbitrary Instruction",permalink:"/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction"}},l={},d=[],c={toc:d};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function depositReserveToken(\n    bool isSourceNative,\n    bytes memory swapData,\n    bytes memory executeData\n) external payable;\n")),(0,a.kt)("p",null,"Reserve tokens are the tokens that have been kept in reserve by the Voyager protocol. The Voyager keeps reserves of some selected tokens on each chain so that it is able to provide fund transfers by locking funds on source chain and unlocking the funds on the destination chain. These include some stable tokens, wrapped native tokens for that chain as well as other tokens according to the needs as well as partnerships of projects with the Voyager ."),(0,a.kt)("p",null,"When a user wants to transfer any of these reserve tokens from source chain to any other token on the destination chain, this function is to be called. After this function is called, the Voyager\u2019s infrastructure will handle the transfer of tokens to the other chain."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters:")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"isSourceNative"),(0,a.kt)("th",{parentName:"tr",align:null},"If the source token is the native token for that chain, this should be true."))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"swapData"),(0,a.kt)("td",{parentName:"tr",align:null},"abi encoded data for the required swap which is created by an API")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"executeData"),(0,a.kt)("td",{parentName:"tr",align:null},"abi encoded data for the execution on the destination chain which is created by an API")))),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Swap Data")," includes: "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcStableTokenAmount:")," Amount of the reserve token the user wants to transfer to the other chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcStableTokenAddress:")," Address of the reserve token the user wants to transfer to the other chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcTokenAddress:")," Address of the token the user wants to transfer to the other chain. This will be the same as srcStableTokenAddress in case of reserve tokens."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destChainIdBytes:")," The Chain ID identifier for the destination chain.")),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Execute Data")," includes: "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destTokenAmount:")," Amount of destination tokens user will receive. This will be checked in the middleware and if this amount (USD Value) is larger than what user deposited, the transaction will be reverted."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destTokenAddress:")," Address of the token user will receive on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"isDestNative:")," If the token to be received on the destination chain is native token for that chain, this is set to 1 else 0."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destStableTokenAddress:")," Address of the stable token in which USD value for the tokens to be received will be calculated on the middleware."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"recipient:")," Address of the recipient on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"dataTx:")," Data for the transaction for swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the dataTx will be an empty bytes array."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"path:")," Path for the swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the path will be an empty address array."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"flags:")," The identifiers of DEXes that will be used for swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the flags will be an empty uint256 array."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"widgetID:")," Widget ID of the partner who has integrated the Voyager Widget. If you are not a partner, you can pass uint256 0 as widgetID.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"All these data will directly be generated by the API. You don\u2019t need to worry about generating this data.")))}h.isMDXComponent=!0}}]);